name: Local Test Build and Deploy

on:
  # 'main' 브랜치에 코드가 푸시될 때마다 이 워크플로우를 실행합니다.
  push:
    branches:
      - main

jobs:
  build-and-deploy-local:
    # 3단계에서 설치한 '내부 집사' Runner에서 이 작업을 실행하도록 지정
    runs-on: self-hosted

    steps:
      # 1. GitHub 리포지토리의 소스 코드를 Runner로 가져옵니다.
      - name: Checkout source code
        uses: actions/checkout@v3

      # 2. Docker 이미지에 사용할 이름과 태그를 설정합니다.
      - name: Set up image name and tag
        id: set-vars
        run: |
          # 컨테이너 이름으로 사용할 수 있도록 리포지토리 이름에서 '/'를 '-'로 변경
          CONTAINER_NAME=$(echo ${{ github.repository }} | sed 's/\//-/g')
          IMAGE_TAG=local-test-$(date +%Y%m%d%H%M)-${{ github.sha | cut -c1-7 }}
          
          # 이후 단계에서 사용할 수 있도록 환경 변수로 설정
          echo "IMAGE_NAME=localhost:5000/${{ github.repository }}:${IMAGE_TAG}" >> $GITHUB_ENV
          echo "CONTAINER_NAME=${CONTAINER_NAME}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

      # 3. Dockerfile을 사용하여 이미지를 빌드하고, 로컬 레지스트리에 푸시합니다.
      - name: Build and push Docker image to local registry
        run: |
          docker build -t ${{ env.IMAGE_NAME }} .
          docker push ${{ env.IMAGE_NAME }}
      
      # 4. 새로 빌드한 이미지로 로컬에 컨테이너를 배포합니다.
      - name: Deploy the new container locally
        run: |
          # 이름이 충돌하지 않도록 기존에 실행 중인 컨테이너가 있다면 중지하고 삭제합니다.
          docker stop ${{ env.CONTAINER_NAME }} || true
          docker rm ${{ env.CONTAINER_NAME }} || true

          # 로컬 레지스트리에서 새 이미지를 사용하여 컨테이너를 실행합니다.
          # -d: 백그라운드 실행
          # -p 8080:8080: 로컬 PC의 8080 포트와 컨테이너의 8080 포트를 연결
          # -e IMAGE_TAG=...: 컨테이너 내부의 앱이 이미지 태그를 알 수 있도록 환경변수 전달
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p 8080:8080 \
            -e IMAGE_TAG=${{ env.IMAGE_TAG }} \
            ${{ env.IMAGE_NAME }} 